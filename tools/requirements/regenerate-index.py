#!/usr/bin/env python3
"""
Regenerate INDEX.md from scratch by scanning all spec/*.md files.

This script:
1. Scans all spec/*.md files (except INDEX.md, README.md, requirements-format.md)
2. Extracts all requirements with ID, title, hash, and file
3. Generates a completely new INDEX.md with sorted requirements
"""

import argparse
import re
import sys
from pathlib import Path
from typing import List, Tuple
from requirement_hash import calculate_requirement_hash, clean_requirement_body


def parse_requirements_from_file(file_path: Path) -> List[Tuple[str, str, str, str]]:
    """
    Parse requirements from a spec file.
    Returns list of (req_id, file_name, title, hash)
    """
    content = file_path.read_text(encoding='utf-8')
    requirements = []

    # Pattern to find REQ headers (any level)
    # Supports both core REQs (REQ-d00001) and sponsor-specific REQs (REQ-CAL-d00001)
    req_pattern = re.compile(r'^(#{1,6})\s+REQ-(?:([A-Z]{2,4})-)?([pod]\d{5}):\s+(.+)$', re.MULTILINE)

    # Pattern to find status line
    status_pattern = re.compile(
        r'^\*\*Level\*\*:\s+(.+?)\s+\|\s+'
        r'\*\*Implements\*\*:\s+(.+?)\s+\|\s+'
        r'\*\*Status\*\*:\s+(.+?)\s*$',
        re.MULTILINE
    )

    # Pattern to find end marker
    end_pattern = re.compile(
        r'^\*End\*\s+\*(.+?)\*\s+\|\s+\*\*Hash\*\*:\s+([a-f0-9]{8}|TBD)\s*$',
        re.MULTILINE
    )

    for header_match in req_pattern.finditer(content):
        sponsor_prefix = header_match.group(2)  # Optional, e.g., "CAL"
        base_id = header_match.group(3)  # e.g., "d00001"
        title = header_match.group(4).strip()
        # Construct full req_id
        req_id = f"{sponsor_prefix}-{base_id}" if sponsor_prefix else base_id

        # Extract content after header
        req_start = header_match.end()
        remaining = content[req_start:]

        # Find status line
        status_match = status_pattern.search(remaining)
        if not status_match:
            print(f"‚ö†Ô∏è  {file_path.name}: REQ-{req_id} missing status line, skipping")
            continue

        # Find end marker
        end_marker_match = end_pattern.search(remaining[status_match.end():])
        if not end_marker_match:
            print(f"‚ö†Ô∏è  {file_path.name}: REQ-{req_id} missing end marker, skipping")
            continue

        # Extract hash from end marker
        req_hash = end_marker_match.group(2)

        requirements.append((req_id, file_path.name, title, req_hash))

    return requirements


def generate_index_md(spec_dir: Path, all_reqs: List[Tuple[str, str, str, str]]) -> str:
    """Generate INDEX.md content from requirements list."""

    # Sort requirements by ID
    all_reqs.sort(key=lambda x: x[0])

    # Generate header
    content = """# Requirements Index

This file provides a complete index of all formal requirements across the spec/ directory. Each requirement is listed with its ID, containing file, and title.

**Maintenance Rules:**
- When adding a new requirement, add it to this index with the correct file reference and hash (calculate from requirement body)
- When modifying a requirement, update its hash using `python3 tools/requirements/update-REQ-hashes.py`
- When moving a requirement to a different file, update the file reference
- When removing/deprecating a requirement, change its file reference to `obsolete` and leave description blank
- Keep requirements sorted by ID (REQ-p, REQ-o, REQ-d in ascending numerical order)
- Hash format: First 8 characters of SHA-256 of requirement body text

---

| Requirement ID | File | Title | Hash |
|----------------|------|-------|------|
"""

    # Generate table rows
    for req_id, file_name, title, req_hash in all_reqs:
        content += f"| REQ-{req_id} | {file_name} | {title} | {req_hash} |\n"

    content += "\n---\n\n"
    content += f"**Total Requirements**: {len(all_reqs)}\n\n"
    content += "**Generated by**: `python3 tools/requirements/regenerate-index.py`\n"

    return content


def main():
    parser = argparse.ArgumentParser(
        description='Regenerate INDEX.md from spec files',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='''
Examples:
  # Regenerate INDEX.md in current repo
  python regenerate-index.py

  # Regenerate INDEX.md in a different repo
  python regenerate-index.py --path /path/to/other/repo

  # Regenerate INDEX.md in sibling repo
  python regenerate-index.py --path ../sibling-repo
'''
    )
    parser.add_argument('--path', type=Path, help='Path to repository root (default: auto-detect from script location)')
    args = parser.parse_args()

    if args.path:
        repo_root = args.path.resolve()
        spec_dir = repo_root / 'spec'
    else:
        script_dir = Path(__file__).parent
        spec_dir = script_dir.parent.parent / 'spec'
    index_path = spec_dir / 'INDEX.md'

    if not spec_dir.exists():
        print(f"‚ùå Spec directory not found: {spec_dir}")
        sys.exit(1)

    print("üìñ Scanning spec/ files for requirements...\n")

    # Parse all requirements from spec files
    all_reqs = []
    skip_files = ['INDEX.md', 'README.md', 'requirements-format.md']

    for spec_file in sorted(spec_dir.glob('*.md')):
        if spec_file.name in skip_files:
            continue

        reqs = parse_requirements_from_file(spec_file)
        all_reqs.extend(reqs)
        if reqs:
            print(f"  ‚úì {spec_file.name}: {len(reqs)} requirements")

    print(f"\n  Total: {len(all_reqs)} requirements\n")

    # Generate INDEX.md
    print("üìù Generating INDEX.md...\n")
    index_content = generate_index_md(spec_dir, all_reqs)

    # Write INDEX.md
    index_path.write_text(index_content, encoding='utf-8')

    print(f"{'='*60}")
    print(f"‚úÖ INDEX.md regenerated with {len(all_reqs)} requirements")
    print(f"   Location: {index_path}")

    return 0


if __name__ == '__main__':
    sys.exit(main())
