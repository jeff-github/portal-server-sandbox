// IMPLEMENTS REQUIREMENTS:
//   REQ-d00005: Sponsor Configuration Detection Implementation
//   REQ-p70007: Linking Code Lifecycle Management
//   REQ-d00078: Linking Code Validation
//   REQ-CAL-p00049: Mobile Linking Codes
//   REQ-CAL-p00073: Patient Status Definitions

import 'dart:convert';

import 'package:clinical_diary/config/app_config.dart';
import 'package:clinical_diary/models/user_enrollment.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:http/http.dart' as http;

/// Service for handling patient linking with 10-character codes
/// Uses HTTP calls to server functions for enrollment/linking
class EnrollmentService {
  EnrollmentService({
    FlutterSecureStorage? secureStorage,
    http.Client? httpClient,
  }) : _secureStorage = secureStorage ?? const FlutterSecureStorage(),
       _httpClient = httpClient ?? http.Client();

  static const _storageKey = 'user_enrollment';
  final FlutterSecureStorage _secureStorage;
  final http.Client _httpClient;

  /// Check if user is enrolled
  Future<bool> isEnrolled() async {
    final data = await _secureStorage.read(key: _storageKey);
    return data != null;
  }

  /// Get current enrollment if exists
  Future<UserEnrollment?> getEnrollment() async {
    final data = await _secureStorage.read(key: _storageKey);
    if (data == null) return null;
    try {
      return UserEnrollment.fromJson(jsonDecode(data) as Map<String, dynamic>);
    } catch (e) {
      return null;
    }
  }

  /// Link to clinical trial with a 10-character code (XXXXX-XXXXX)
  /// The code is generated by the sponsor portal and links the app user to a patient.
  /// Returns the enrollment on success, throws on failure.
  ///
  /// REQ-p70007: Linking codes are single-use and expire after 72 hours
  /// REQ-d00078: Code is validated via SHA-256 hash lookup
  Future<UserEnrollment> enroll(String code) async {
    try {
      // Normalize code: uppercase, remove dash
      final normalizedCode = code.toUpperCase().replaceAll('-', '').trim();

      debugPrint('Linking with code: $normalizedCode');

      // Get existing JWT token for authentication
      final jwtToken = await getJwtToken();
      if (jwtToken == null) {
        throw EnrollmentException(
          'Please sign in before linking to a clinical trial.',
          EnrollmentErrorType.authRequired,
        );
      }

      // Get app UUID for tracking
      final appUuid = await _secureStorage.read(key: 'app_uuid');

      // Call the link function via HTTP (REQ-p70007)
      final response = await _httpClient.post(
        Uri.parse(AppConfig.linkUrl),
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer $jwtToken',
        },
        body: jsonEncode({
          'code': normalizedCode,
          if (appUuid != null) 'appUuid': appUuid,
        }),
      );

      debugPrint('Link response status: ${response.statusCode}');
      debugPrint('Link response body: ${response.body}');

      if (response.statusCode == 409) {
        throw EnrollmentException(
          'This code has already been used. Please request a new code from your research coordinator.',
          EnrollmentErrorType.codeAlreadyUsed,
        );
      }

      if (response.statusCode == 410) {
        // Code expired or revoked
        final errorBody = jsonDecode(response.body) as Map<String, dynamic>;
        throw EnrollmentException(
          errorBody['error']?.toString() ??
              'This code has expired. Please request a new code.',
          EnrollmentErrorType.codeExpired,
        );
      }

      if (response.statusCode == 400) {
        final errorBody = jsonDecode(response.body) as Map<String, dynamic>;
        throw EnrollmentException(
          errorBody['error']?.toString() ?? 'Invalid linking code.',
          EnrollmentErrorType.invalidCode,
        );
      }

      if (response.statusCode == 401) {
        throw EnrollmentException(
          'Authentication required. Please sign in again.',
          EnrollmentErrorType.authRequired,
        );
      }

      if (response.statusCode != 200) {
        final errorBody = jsonDecode(response.body) as Map<String, dynamic>;
        throw EnrollmentException(
          errorBody['error']?.toString() ?? 'Server error',
          EnrollmentErrorType.serverError,
        );
      }

      final responseBody = jsonDecode(response.body) as Map<String, dynamic>;

      // Get user ID from existing auth or response
      final userId = await getUserId();
      if (userId == null) {
        throw EnrollmentException(
          'Unable to determine user ID.',
          EnrollmentErrorType.serverError,
        );
      }

      final patientId = responseBody['patientId'] as String?;
      final siteId = responseBody['siteId'] as String?;
      final siteName = responseBody['siteName'] as String?;
      final studyPatientId = responseBody['studyPatientId'] as String?;

      debugPrint(
        'Link successful: patientId=$patientId, siteId=$siteId, siteName=$siteName',
      );

      final enrollment = UserEnrollment(
        userId: userId,
        jwtToken: jwtToken,
        enrolledAt: DateTime.now(),
        patientId: patientId,
        siteId: siteId,
        siteName: siteName,
        studyPatientId: studyPatientId,
      );

      await _saveEnrollment(enrollment);
      return enrollment;
    } on http.ClientException catch (e) {
      debugPrint('HTTP error: $e');
      throw EnrollmentException(
        'Network error. Please check your connection.',
        EnrollmentErrorType.networkError,
      );
    } catch (e, stack) {
      if (e is EnrollmentException) rethrow;

      debugPrint('Link error: $e');
      debugPrint('Stack trace:\n$stack');
      throw EnrollmentException('Error: $e', EnrollmentErrorType.networkError);
    }
  }

  /// Save enrollment to secure storage
  Future<void> _saveEnrollment(UserEnrollment enrollment) async {
    await _secureStorage.write(
      key: _storageKey,
      value: jsonEncode(enrollment.toJson()),
    );
  }

  /// Clear enrollment (for testing or logout)
  Future<void> clearEnrollment() async {
    await _secureStorage.delete(key: _storageKey);
  }

  /// Get JWT token for API calls
  /// Checks enrollment first, then falls back to auth_jwt (for username/password login)
  Future<String?> getJwtToken() async {
    // First check enrollment (CUREHHT code flow)
    final enrollment = await getEnrollment();
    if (enrollment?.jwtToken != null) {
      return enrollment!.jwtToken;
    }
    // Fall back to auth service JWT (username/password login flow)
    return _secureStorage.read(key: 'auth_jwt');
  }

  /// Get user ID from enrollment or auth service
  /// Checks enrollment first, then falls back to auth_username (for username/password login)
  Future<String?> getUserId() async {
    // First check enrollment (CUREHHT code flow)
    final enrollment = await getEnrollment();
    if (enrollment?.userId != null) {
      return enrollment!.userId;
    }
    // Fall back to auth service username (username/password login flow)
    return _secureStorage.read(key: 'auth_username');
  }

  /// Dispose resources
  void dispose() {
    _httpClient.close();
  }
}

/// Types of enrollment/linking errors
enum EnrollmentErrorType {
  invalidCode,
  codeAlreadyUsed,
  codeExpired,
  authRequired,
  serverError,
  networkError,
}

/// Exception thrown during enrollment
class EnrollmentException implements Exception {
  EnrollmentException(this.message, this.type);
  final String message;
  final EnrollmentErrorType type;

  @override
  String toString() => message;
}
