// IMPLEMENTS REQUIREMENTS:
//   REQ-d00005: Sponsor Configuration Detection Implementation
//   REQ-p70007: Linking Code Lifecycle Management
//   REQ-d00078: Linking Code Validation
//   REQ-CAL-p00049: Mobile Linking Codes
//   REQ-CAL-p00073: Patient Status Definitions
//   REQ-CAL-p00020: Patient Disconnection Workflow
//   REQ-CAL-p00077: Disconnection Notification

import 'dart:convert';

import 'package:clinical_diary/config/sponsor_registry.dart';
import 'package:clinical_diary/flavors.dart';
import 'package:clinical_diary/models/user_enrollment.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:http/http.dart' as http;
import 'package:shared_preferences/shared_preferences.dart';

/// Service for handling patient linking with 10-character codes
/// Uses HTTP calls to server functions for enrollment/linking
class EnrollmentService {
  EnrollmentService({
    FlutterSecureStorage? secureStorage,
    http.Client? httpClient,
    SharedPreferences? sharedPreferences,
  }) : _secureStorage = secureStorage ?? const FlutterSecureStorage(),
       _httpClient = httpClient ?? http.Client(),
       _sharedPreferences = sharedPreferences;

  static const _storageKey = 'user_enrollment';
  static const _disconnectedKey = 'patient_disconnected';
  static const _disconnectionBannerDismissedKey =
      'disconnection_banner_dismissed';
  final FlutterSecureStorage _secureStorage;
  final http.Client _httpClient;
  SharedPreferences? _sharedPreferences;

  Future<SharedPreferences> _getPrefs() async {
    _sharedPreferences ??= await SharedPreferences.getInstance();
    return _sharedPreferences!;
  }

  /// Check if user is enrolled
  Future<bool> isEnrolled() async {
    final data = await _secureStorage.read(key: _storageKey);
    return data != null;
  }

  /// Get current enrollment if exists
  Future<UserEnrollment?> getEnrollment() async {
    final data = await _secureStorage.read(key: _storageKey);
    if (data == null) return null;
    try {
      return UserEnrollment.fromJson(jsonDecode(data) as Map<String, dynamic>);
    } catch (e) {
      return null;
    }
  }

  /// Link to clinical trial with a 10-character code (XXXXX-XXXXX)
  /// The code is generated by the sponsor portal and links the app user to a patient.
  /// Returns the enrollment on success, throws on failure.
  ///
  /// The 2-letter prefix of the code determines which sponsor's diary-server to call.
  /// For example, code "CAXXXXXXXX" uses Callisto's backend (prefix "CA").
  ///
  /// REQ-p70007: Linking codes are single-use and expire after 72 hours
  /// REQ-d00078: Code is validated via SHA-256 hash lookup
  Future<UserEnrollment> enroll(String code) async {
    try {
      // Normalize code: uppercase, remove dash
      final normalizedCode = code.toUpperCase().replaceAll('-', '').trim();

      debugPrint('Linking with code: $normalizedCode');

      // Determine which sponsor's backend to call based on code prefix
      String backendUrl;
      try {
        backendUrl = SponsorRegistry.getBackendUrlForCode(
          normalizedCode,
          F.appFlavor,
        );
        debugPrint('Resolved backend URL: $backendUrl');
      } on SponsorRegistryException catch (e) {
        throw EnrollmentException(
          e.message,
          EnrollmentErrorType.unknownSponsor,
        );
      }

      // Build the full link URL for this sponsor's backend
      final linkUrl = '$backendUrl/api/v1/user/link';

      // Get app UUID for tracking (device identifier)
      final appUuid = await _secureStorage.read(key: 'app_uuid');

      // Call the link function via HTTP (REQ-p70007)
      // No JWT required - the linking code IS the authentication
      // Server will create user and return JWT
      final response = await _httpClient.post(
        Uri.parse(linkUrl),
        headers: {'Content-Type': 'application/json'},
        body: jsonEncode({
          'code': normalizedCode,
          if (appUuid != null) 'appUuid': appUuid,
        }),
      );

      debugPrint('Link response status: ${response.statusCode}');
      debugPrint('Link response body: ${response.body}');

      if (response.statusCode == 409) {
        throw EnrollmentException(
          'This code has already been used. Please request a new code from your research coordinator.',
          EnrollmentErrorType.codeAlreadyUsed,
        );
      }

      if (response.statusCode == 410) {
        // Code expired or revoked
        final errorBody = jsonDecode(response.body) as Map<String, dynamic>;
        throw EnrollmentException(
          errorBody['error']?.toString() ??
              'This code has expired. Please request a new code.',
          EnrollmentErrorType.codeExpired,
        );
      }

      if (response.statusCode == 400) {
        final errorBody = jsonDecode(response.body) as Map<String, dynamic>;
        throw EnrollmentException(
          errorBody['error']?.toString() ?? 'Invalid linking code.',
          EnrollmentErrorType.invalidCode,
        );
      }

      if (response.statusCode == 401) {
        throw EnrollmentException(
          'Authentication required. Please sign in again.',
          EnrollmentErrorType.authRequired,
        );
      }

      if (response.statusCode != 200) {
        final errorBody = jsonDecode(response.body) as Map<String, dynamic>;
        throw EnrollmentException(
          errorBody['error']?.toString() ?? 'Server error',
          EnrollmentErrorType.serverError,
        );
      }

      final responseBody = jsonDecode(response.body) as Map<String, dynamic>;

      // Extract JWT and user data from response
      // The /link endpoint creates the user and returns the JWT
      final jwtToken = responseBody['jwt'] as String?;
      final userId = responseBody['userId'] as String?;

      if (jwtToken == null || userId == null) {
        throw EnrollmentException(
          'Server did not return authentication token.',
          EnrollmentErrorType.serverError,
        );
      }

      final patientId = responseBody['patientId'] as String?;
      final siteId = responseBody['siteId'] as String?;
      final siteName = responseBody['siteName'] as String?;
      final studyPatientId = responseBody['studyPatientId'] as String?;

      // Get sponsor info from registry for storage
      final prefix = SponsorRegistry.extractPrefix(normalizedCode);
      final sponsor = SponsorRegistry.getByPrefix(prefix);

      debugPrint(
        'Link successful: patientId=$patientId, siteId=$siteId, '
        'siteName=$siteName, sponsor=${sponsor?.id}',
      );

      final enrollment = UserEnrollment(
        userId: userId,
        jwtToken: jwtToken,
        enrolledAt: DateTime.now(),
        sponsorId: sponsor?.id,
        backendUrl: backendUrl,
        patientId: patientId,
        siteId: siteId,
        siteName: siteName,
        studyPatientId: studyPatientId,
      );

      await _saveEnrollment(enrollment);
      return enrollment;
    } on http.ClientException catch (e) {
      debugPrint('HTTP error: $e');
      throw EnrollmentException(
        'Network error. Please check your connection.',
        EnrollmentErrorType.networkError,
      );
    } catch (e, stack) {
      if (e is EnrollmentException) rethrow;

      debugPrint('Link error: $e');
      debugPrint('Stack trace:\n$stack');
      throw EnrollmentException('Error: $e', EnrollmentErrorType.networkError);
    }
  }

  /// Save enrollment to secure storage
  Future<void> _saveEnrollment(UserEnrollment enrollment) async {
    await _secureStorage.write(
      key: _storageKey,
      value: jsonEncode(enrollment.toJson()),
    );
  }

  /// Clear enrollment (for testing or logout)
  Future<void> clearEnrollment() async {
    await _secureStorage.delete(key: _storageKey);
  }

  /// Get JWT token for API calls
  /// Checks enrollment first, then falls back to auth_jwt (for username/password login)
  Future<String?> getJwtToken() async {
    // First check enrollment (CUREHHT code flow)
    final enrollment = await getEnrollment();
    if (enrollment?.jwtToken != null) {
      return enrollment!.jwtToken;
    }
    // Fall back to auth service JWT (username/password login flow)
    return _secureStorage.read(key: 'auth_jwt');
  }

  /// Get user ID from enrollment or auth service
  /// Checks enrollment first, then falls back to auth_username (for username/password login)
  Future<String?> getUserId() async {
    // First check enrollment (CUREHHT code flow)
    final enrollment = await getEnrollment();
    if (enrollment?.userId != null) {
      return enrollment!.userId;
    }
    // Fall back to auth service username (username/password login flow)
    return _secureStorage.read(key: 'auth_username');
  }

  /// Get the backend URL for API calls.
  /// Uses the stored enrollment's backend URL if available.
  /// This should be used for sync, records, and other API calls
  /// that need to go to the correct sponsor's diary-server.
  Future<String?> getBackendUrl() async {
    final enrollment = await getEnrollment();
    return enrollment?.backendUrl;
  }

  /// Get the full URL for the sync endpoint.
  /// Returns null if not enrolled with a backend URL.
  Future<String?> getSyncUrl() async {
    final baseUrl = await getBackendUrl();
    if (baseUrl == null) return null;
    return '$baseUrl/api/v1/user/sync';
  }

  /// Get the full URL for the records endpoint.
  /// Returns null if not enrolled with a backend URL.
  Future<String?> getRecordsUrl() async {
    final baseUrl = await getBackendUrl();
    if (baseUrl == null) return null;
    return '$baseUrl/api/v1/user/records';
  }

  // REQ-CAL-p00077: Disconnection status tracking

  /// Check if the patient has been disconnected from the study
  Future<bool> isDisconnected() async {
    final prefs = await _getPrefs();
    return prefs.getBool(_disconnectedKey) ?? false;
  }

  /// Set the disconnection status
  /// Called when sync response indicates patient is disconnected
  Future<void> setDisconnected(bool disconnected) async {
    final prefs = await _getPrefs();
    await prefs.setBool(_disconnectedKey, disconnected);

    // If reconnected, also clear the banner dismissed state
    if (!disconnected) {
      await prefs.remove(_disconnectionBannerDismissedKey);
    }
  }

  /// Check if the disconnection banner has been dismissed by the user
  /// The banner reappears on app restart even if dismissed
  Future<bool> isDisconnectionBannerDismissed() async {
    final prefs = await _getPrefs();
    return prefs.getBool(_disconnectionBannerDismissedKey) ?? false;
  }

  /// Set the banner dismissed state
  /// Called when user taps the dismiss button
  Future<void> setDisconnectionBannerDismissed(bool dismissed) async {
    final prefs = await _getPrefs();
    await prefs.setBool(_disconnectionBannerDismissedKey, dismissed);
  }

  /// Reset banner dismissed state (called on app restart)
  Future<void> resetDisconnectionBannerDismissed() async {
    final prefs = await _getPrefs();
    await prefs.remove(_disconnectionBannerDismissedKey);
  }

  /// Process a sync/records response to check for disconnection status
  /// Returns true if the patient is disconnected
  bool processDisconnectionStatus(Map<String, dynamic> response) {
    final isDisconnected = response['isDisconnected'] as bool? ?? false;
    final status = response['mobileLinkingStatus'] as String?;

    debugPrint(
      '[ENROLLMENT] Checking disconnection: status=$status, isDisconnected=$isDisconnected',
    );

    // Update local disconnection state asynchronously
    setDisconnected(isDisconnected);

    return isDisconnected;
  }

  /// Dispose resources
  void dispose() {
    _httpClient.close();
  }
}

/// Types of enrollment/linking errors
enum EnrollmentErrorType {
  invalidCode,
  codeAlreadyUsed,
  codeExpired,
  authRequired,
  serverError,
  networkError,
  unknownSponsor,
}

/// Exception thrown during enrollment
class EnrollmentException implements Exception {
  EnrollmentException(this.message, this.type);
  final String message;
  final EnrollmentErrorType type;

  @override
  String toString() => message;
}
