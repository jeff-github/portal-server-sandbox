// IMPLEMENTS REQUIREMENTS:
//   REQ-d00005: Sponsor Configuration Detection Implementation
//   REQ-p70007: Linking Code Lifecycle Management
//   REQ-d00078: Linking Code Validation
//   REQ-CAL-p00049: Mobile Linking Codes
//   REQ-CAL-p00073: Patient Status Definitions

import 'dart:convert';

import 'package:clinical_diary/config/sponsor_registry.dart';
import 'package:clinical_diary/flavors.dart';
import 'package:clinical_diary/models/user_enrollment.dart';
import 'package:flutter/foundation.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';
import 'package:http/http.dart' as http;

/// Service for handling patient linking with 10-character codes
/// Uses HTTP calls to server functions for enrollment/linking
class EnrollmentService {
  EnrollmentService({
    FlutterSecureStorage? secureStorage,
    http.Client? httpClient,
  }) : _secureStorage = secureStorage ?? const FlutterSecureStorage(),
       _httpClient = httpClient ?? http.Client();

  static const _storageKey = 'user_enrollment';
  final FlutterSecureStorage _secureStorage;
  final http.Client _httpClient;

  /// Check if user is enrolled
  Future<bool> isEnrolled() async {
    final data = await _secureStorage.read(key: _storageKey);
    return data != null;
  }

  /// Get current enrollment if exists
  Future<UserEnrollment?> getEnrollment() async {
    final data = await _secureStorage.read(key: _storageKey);
    if (data == null) return null;
    try {
      return UserEnrollment.fromJson(jsonDecode(data) as Map<String, dynamic>);
    } catch (e) {
      return null;
    }
  }

  /// Link to clinical trial with a 10-character code (XXXXX-XXXXX)
  /// The code is generated by the sponsor portal and links the app user to a patient.
  /// Returns the enrollment on success, throws on failure.
  ///
  /// The 2-letter prefix of the code determines which sponsor's diary-server to call.
  /// For example, code "CAXXXXXXXX" uses Callisto's backend (prefix "CA").
  ///
  /// REQ-p70007: Linking codes are single-use and expire after 72 hours
  /// REQ-d00078: Code is validated via SHA-256 hash lookup
  Future<UserEnrollment> enroll(String code) async {
    try {
      // Normalize code: uppercase, remove dash
      final normalizedCode = code.toUpperCase().replaceAll('-', '').trim();

      debugPrint('Linking with code: $normalizedCode');

      // Determine which sponsor's backend to call based on code prefix
      String backendUrl;
      try {
        backendUrl = SponsorRegistry.getBackendUrlForCode(
          normalizedCode,
          F.appFlavor,
        );
        debugPrint('Resolved backend URL: $backendUrl');
      } on SponsorRegistryException catch (e) {
        throw EnrollmentException(
          e.message,
          EnrollmentErrorType.unknownSponsor,
        );
      }

      // Build the full link URL for this sponsor's backend
      final linkUrl = '$backendUrl/api/v1/user/link';

      // Get app UUID for tracking (device identifier)
      final appUuid = await _secureStorage.read(key: 'app_uuid');

      // Call the link function via HTTP (REQ-p70007)
      // No JWT required - the linking code IS the authentication
      // Server will create user and return JWT
      final response = await _httpClient.post(
        Uri.parse(linkUrl),
        headers: {'Content-Type': 'application/json'},
        body: jsonEncode({
          'code': normalizedCode,
          if (appUuid != null) 'appUuid': appUuid,
        }),
      );

      debugPrint('Link response status: ${response.statusCode}');
      debugPrint('Link response body: ${response.body}');

      if (response.statusCode == 409) {
        throw EnrollmentException(
          'This code has already been used. Please request a new code from your research coordinator.',
          EnrollmentErrorType.codeAlreadyUsed,
        );
      }

      if (response.statusCode == 410) {
        // Code expired or revoked
        final errorBody = jsonDecode(response.body) as Map<String, dynamic>;
        throw EnrollmentException(
          errorBody['error']?.toString() ??
              'This code has expired. Please request a new code.',
          EnrollmentErrorType.codeExpired,
        );
      }

      if (response.statusCode == 400) {
        final errorBody = jsonDecode(response.body) as Map<String, dynamic>;
        throw EnrollmentException(
          errorBody['error']?.toString() ?? 'Invalid linking code.',
          EnrollmentErrorType.invalidCode,
        );
      }

      if (response.statusCode == 401) {
        throw EnrollmentException(
          'Authentication required. Please sign in again.',
          EnrollmentErrorType.authRequired,
        );
      }

      if (response.statusCode != 200) {
        final errorBody = jsonDecode(response.body) as Map<String, dynamic>;
        throw EnrollmentException(
          errorBody['error']?.toString() ?? 'Server error',
          EnrollmentErrorType.serverError,
        );
      }

      final responseBody = jsonDecode(response.body) as Map<String, dynamic>;

      // Extract JWT and user data from response
      // The /link endpoint creates the user and returns the JWT
      final jwtToken = responseBody['jwt'] as String?;
      final userId = responseBody['userId'] as String?;

      if (jwtToken == null || userId == null) {
        throw EnrollmentException(
          'Server did not return authentication token.',
          EnrollmentErrorType.serverError,
        );
      }

      final patientId = responseBody['patientId'] as String?;
      final siteId = responseBody['siteId'] as String?;
      final siteName = responseBody['siteName'] as String?;
      final studyPatientId = responseBody['studyPatientId'] as String?;

      // Get sponsor info from registry for storage
      final prefix = SponsorRegistry.extractPrefix(normalizedCode);
      final sponsor = SponsorRegistry.getByPrefix(prefix);

      debugPrint(
        'Link successful: patientId=$patientId, siteId=$siteId, '
        'siteName=$siteName, sponsor=${sponsor?.id}',
      );

      final enrollment = UserEnrollment(
        userId: userId,
        jwtToken: jwtToken,
        enrolledAt: DateTime.now(),
        sponsorId: sponsor?.id,
        backendUrl: backendUrl,
        patientId: patientId,
        siteId: siteId,
        siteName: siteName,
        studyPatientId: studyPatientId,
      );

      await _saveEnrollment(enrollment);
      return enrollment;
    } on http.ClientException catch (e) {
      debugPrint('HTTP error: $e');
      throw EnrollmentException(
        'Network error. Please check your connection.',
        EnrollmentErrorType.networkError,
      );
    } catch (e, stack) {
      if (e is EnrollmentException) rethrow;

      debugPrint('Link error: $e');
      debugPrint('Stack trace:\n$stack');
      throw EnrollmentException('Error: $e', EnrollmentErrorType.networkError);
    }
  }

  /// Save enrollment to secure storage
  Future<void> _saveEnrollment(UserEnrollment enrollment) async {
    await _secureStorage.write(
      key: _storageKey,
      value: jsonEncode(enrollment.toJson()),
    );
  }

  /// Clear enrollment (for testing or logout)
  Future<void> clearEnrollment() async {
    await _secureStorage.delete(key: _storageKey);
  }

  /// Get JWT token for API calls
  /// Checks enrollment first, then falls back to auth_jwt (for username/password login)
  Future<String?> getJwtToken() async {
    // First check enrollment (CUREHHT code flow)
    final enrollment = await getEnrollment();
    if (enrollment?.jwtToken != null) {
      return enrollment!.jwtToken;
    }
    // Fall back to auth service JWT (username/password login flow)
    return _secureStorage.read(key: 'auth_jwt');
  }

  /// Get user ID from enrollment or auth service
  /// Checks enrollment first, then falls back to auth_username (for username/password login)
  Future<String?> getUserId() async {
    // First check enrollment (CUREHHT code flow)
    final enrollment = await getEnrollment();
    if (enrollment?.userId != null) {
      return enrollment!.userId;
    }
    // Fall back to auth service username (username/password login flow)
    return _secureStorage.read(key: 'auth_username');
  }

  /// Get the backend URL for API calls.
  /// Uses the stored enrollment's backend URL if available.
  /// This should be used for sync, records, and other API calls
  /// that need to go to the correct sponsor's diary-server.
  Future<String?> getBackendUrl() async {
    final enrollment = await getEnrollment();
    return enrollment?.backendUrl;
  }

  /// Get the full URL for the sync endpoint.
  /// Returns null if not enrolled with a backend URL.
  Future<String?> getSyncUrl() async {
    final baseUrl = await getBackendUrl();
    if (baseUrl == null) return null;
    return '$baseUrl/api/v1/user/sync';
  }

  /// Get the full URL for the records endpoint.
  /// Returns null if not enrolled with a backend URL.
  Future<String?> getRecordsUrl() async {
    final baseUrl = await getBackendUrl();
    if (baseUrl == null) return null;
    return '$baseUrl/api/v1/user/records';
  }

  /// Dispose resources
  void dispose() {
    _httpClient.close();
  }
}

/// Types of enrollment/linking errors
enum EnrollmentErrorType {
  invalidCode,
  codeAlreadyUsed,
  codeExpired,
  authRequired,
  serverError,
  networkError,
  unknownSponsor,
}

/// Exception thrown during enrollment
class EnrollmentException implements Exception {
  EnrollmentException(this.message, this.type);
  final String message;
  final EnrollmentErrorType type;

  @override
  String toString() => message;
}
