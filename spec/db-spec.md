# PRD: Clinical Trial Diary Database Architecture

## Document Information
- **Version**: 1.0
- **Last Updated**: 2025
- **Status**: Draft
- **Compliance**: FDA 21 CFR Part 11

---

## Executive Summary

A PostgreSQL-based database system for clinical trial patient diary data with offline-first mobile app support, complete audit trail for FDA compliance, and multi-site access control.

**Architecture Pattern**: Event Sourcing with CQRS (Command Query Responsibility Segregation)

---

## Core Database Architecture

### Event Sourcing Pattern

This system implements **Event Sourcing** - all changes are stored as a sequence of immutable events, with current state derived from replaying those events.

### 1. Event Store (record_audit table)
- **Immutable append-only log** - no updates or deletes allowed
- Records every state change as an event
- Each event contains:
  - Auto-incrementing audit ID (establishes order)
  - Event UUID (generated by mobile app)
  - Patient ID
  - Site ID
  - Full data snapshot (JSONB)
  - Actor (user/investigator/admin who made change)
  - Timestamps (client-side and server-side)
  - Change reason (required for audit trail)
  - Parent audit ID (tracks event lineage)
- **Source of truth** for all data
- Enables point-in-time reconstruction of any record
- Supports event replay and temporal queries

### 2. Read Model (record_state table)
- **Materialized view** of current state
- One row per diary entry (derived from event stream)
- Automatically updated via database triggers
- Each row contains:
  - Event UUID (primary key, generated by app)
  - Patient ID
  - Site ID
  - Current data (JSONB)
  - Version number (count of events)
  - Reference to last audit entry
  - Sync metadata
  - Soft delete flag
- **Optimized for queries** (CQRS read side)
- Application queries this table, not the event store
- Can be rebuilt from event store if needed

### 3. Annotations Table (Investigator Layer)
- Investigator notes and corrections stored separately
- Does not modify user's original data
- Links to specific audit entries
- Supports query/response workflow between investigator and patient

### 4. Supporting Tables
- Sites (site metadata)
- User-site assignments (patient enrollment)
- Investigator-site assignments (access control)
- Conflict tracking (for multi-device sync)

---

## Data Identification

### UUID Generation
- **UUIDs generated by mobile app** (client-side)
- Ensures offline-first functionality
- Same UUID used across multiple database instances
- Prevents duplicate key conflicts during sync
- Format: UUID v4 (random)

### Multi-Database Support
- App may post same event to multiple databases (e.g., backup, regional)
- Shared UUID maintains referential integrity across databases
- Each database maintains independent audit trail
- Synchronization conflicts resolved at application layer

---

## Database Enforcement Rules

### 1. Referential Integrity
- Enforced via PostgreSQL foreign key constraints
- Cascading rules defined for deletions (where applicable)
- Orphaned records prevented at database level

### 2. Data Validation
- Database triggers validate data format and ranges
- Required fields enforced via NOT NULL constraints
- CHECK constraints for enum-like fields
- JSONB schema validation via triggers

### 3. Event Store Maintenance
- **Database triggers** automatically update read model when events are written
- Trigger ensures atomic transaction: both event store write and read model update
- Failed transactions rollback both tables
- No application code can bypass event logging

### 4. Read Model Derivation
- Trigger on event store automatically updates read model
- Application cannot directly update read model (enforced by permissions)
- Ensures read model always reflects event history
- Read model can be rebuilt by replaying events

---

## Access Control (RBAC)

### Role Definitions

#### 1. **User (Patient)**
- Can create and modify own diary entries only
- Cannot access other patients' data
- Cannot access investigator functions
- Can view investigator annotations on own entries

#### 2. **Investigator**
- Read access to all patients at assigned site(s)
- Can add annotations and corrections (logged separately)
- Can transcribe paper diaries
- Can send queries to patients
- Cannot access patients at other sites
- Cannot modify raw patient data (only annotate)

#### 3. **Analyst**
- Read-only access to de-identified data at assigned site(s)
- Can export data for analysis
- Cannot modify any data
- Cannot see PII beyond patient study ID

#### 4. **Admin**
- Global read access to all data
- Can assign users to sites
- Can assign investigators to sites
- Can perform data corrections (with justification and audit trail)
- All admin actions require additional authentication
- Admin modifications flagged for investigator review

### PostgreSQL Row-Level Security (RLS)

#### User Isolation Policy
```sql
-- Users can only access their own records
CREATE POLICY user_isolation ON record_state
  FOR ALL
  TO user_role
  USING (patient_id = current_user_id());
```

#### Site-Based Investigator Access Policy
```sql
-- Investigators can access patients at their assigned sites
CREATE POLICY investigator_site_access ON record_state
  FOR SELECT
  TO investigator_role
  USING (
    site_id IN (
      SELECT site_id 
      FROM investigator_site_assignments 
      WHERE investigator_id = current_user_id()
    )
  );
```

#### Analyst Access Policy
```sql
-- Analysts can access de-identified data at their sites
CREATE POLICY analyst_site_access ON record_state
  FOR SELECT
  TO analyst_role
  USING (
    site_id IN (
      SELECT site_id 
      FROM analyst_site_assignments 
      WHERE analyst_id = current_user_id()
    )
  );
```

#### Admin Override Policy
```sql
-- Admins have global access but all actions are logged
CREATE POLICY admin_global_access ON record_state
  FOR ALL
  TO admin_role
  USING (true)
  WITH CHECK (log_admin_action());
```

### Database Role Assignment
- Roles assigned via PostgreSQL `GRANT` statements
- Users authenticate via JWT tokens containing role claims
- Supabase automatically sets PostgreSQL session role based on JWT
- Role changes require admin approval and are audited

---

## Conflict Resolution

### Multi-Device Sync Conflicts
- Detected when `parent_audit_id` doesn't match current state
- Client must resolve before server accepts update
- Resolution strategies:
  - User chooses version (client or server)
  - Field-level merge (non-conflicting fields combined)
  - Manual review UI for true conflicts
- Resolution creates new audit entry with conflict metadata

### Investigator vs. User Conflicts
- Not true conflicts - stored as separate layers
- User data remains authoritative
- Investigator corrections stored as annotations
- Both visible to patient on next sync

---

## Data Synchronization

### Offline-First App Architecture
- Mobile app stores data locally (IndexedDB/SQLite)
- Changes queued for sync when online
- Background sync every 15 minutes when connected
- Delta sync: only changed records transmitted

### Sync Protocol
1. App sends: event UUID, data, parent_audit_id, client timestamp
2. Database checks for conflicts (parent_audit_id match)
3. If no conflict: accept and return new audit_id
4. If conflict: return current state and conflict indicator
5. App resolves conflict and resubmits
6. Database writes event to event store and updates read model

### Batch Operations
- App can submit multiple events in single transaction
- All-or-nothing: entire batch succeeds or fails
- Reduces network overhead for catch-up syncs

---

## FDA 21 CFR Part 11 Compliance

### Electronic Records (§11.10)
- ✓ System validation before deployment
- ✓ Audit trail cannot be modified (insert-only table)
- ✓ Time-stamped audit trail with user identification
- ✓ Data validation at input (database triggers)
- ✓ System access controls (RLS policies)

### Electronic Signatures (§11.50)
- Two-factor authentication for critical operations
- Signature includes: user ID, timestamp, meaning, reason
- Signature cryptographically linked to record
- Cannot be copied, transferred, or excised

### Audit Trail Requirements
- Every modification creates audit entry before state update
- Audit includes: who, what, when, why
- Old and new values both preserved
- Complete chain of custody maintained

---

## Data Model Summary

### Core Tables
1. **record_audit** - Event store (immutable event log for Event Sourcing)
2. **record_state** - Read model (current state view derived from event store)
3. **investigator_annotations** - Notes/corrections layer
4. **sites** - Clinical trial site information
5. **user_site_assignments** - Patient enrollment per site
6. **investigator_site_assignments** - Investigator access per site
7. **analyst_site_assignments** - Analyst access per site
8. **audit_conflicts** - Multi-device sync conflict tracking

### Key Fields
- **Event UUID**: Client-generated, globally unique identifier (same across databases)
- **Patient ID**: Links to user authentication system
- **Site ID**: Clinical trial site for RBAC
- **Audit ID**: Auto-incrementing event ID, establishes chronological order in event store
- **Parent Audit ID**: Links to previous event for version tracking (Event Sourcing lineage)
- **Data (JSONB)**: Flexible schema for diary events
- **Timestamps**: Client and server, with timezone
- **Change Reason**: Required for all modifications

---

## Performance Considerations

### Indexing Strategy
- Primary keys on all tables
- Indexes on: patient_id, site_id, UUID, timestamps
- GIN index on JSONB columns for fast queries
- Partial indexes for common filters (e.g., pending sync)

### Partitioning
- Event store (record_audit) partitioned by month (performance)
- Old partitions archived to cold storage after 2 years
- Read model (record_state) not partitioned (always small)

### Scaling
- Read replicas for investigator portal queries
- Connection pooling (PgBouncer)
- Materialized views for common aggregate queries
- Automatic vacuum and analyze scheduled

---

## Security Requirements

### Encryption
- Database encrypted at rest (AES-256)
- All connections use TLS 1.3
- JWT tokens for authentication
- Passwords hashed with bcrypt

### Access Logging
- All database connections logged
- Failed authentication attempts logged
- Admin actions logged with justification
- Suspicious patterns trigger alerts

### Backup and Recovery
- Automated backups every 6 hours
- 30-day point-in-time recovery
- Cross-region replication for disaster recovery
- Backup encryption with separate keys

---

## Data Types and Formats

### JSONB Schema Examples
```json
{
  "event_type": "epistaxis",
  "date": "2025-01-15",
  "time": "14:30",
  "duration_minutes": 15,
  "intensity": "moderate",
  "side": "right",
  "notes": "Started after exercise"
}
```

### Audit Entry Structure
```json
{
  "audit_id": 12345,
  "event_uuid": "550e8400-e29b-41d4-a716-446655440000",
  "patient_id": "user_abc123",
  "site_id": "site_001",
  "operation": "USER_UPDATE",
  "data": { /* current snapshot */ },
  "created_by": "user_abc123",
  "role": "USER",
  "client_timestamp": "2025-01-15T14:35:00Z",
  "server_timestamp": "2025-01-15T14:35:02Z",
  "parent_audit_id": 12340,
  "change_reason": "Corrected duration estimate"
}
```

---

## Future Enhancements

### Phase 2 (6-12 months)
- Real-time sync via WebSockets
- Advanced analytics dashboard
- Machine learning for data quality checks
- Integration with electronic health records (EHR)

### Phase 3 (12-24 months)
- Multi-language support
- Blockchain-based audit trail (optional)
- Federated learning across trials
- Advanced query builder for researchers

---

## Success Metrics

### Data Quality
- 100% audit trail completeness (no missing entries)
- <5% sync conflict rate
- <1% manual conflict resolution rate
- 99.9%+ data integrity verification success

### Performance
- <3 seconds average sync time
- <100ms database query latency (95th percentile)
- 99.9% API uptime
- Support 10,000 concurrent users

### Compliance
- Zero critical FDA audit findings
- 100% of corrections properly documented
- Zero unauthorized data access incidents
- 100% backup success rate

---

## Appendix: Database Schema Quick Reference
```
record_audit (INSERT-only)
├─ audit_id (PK, auto-increment)
├─ event_uuid (from app)
├─ patient_id
├─ site_id
├─ operation
├─ data (JSONB)
├─ created_by
├─ role
├─ client_timestamp
├─ server_timestamp
├─ parent_audit_id (FK → audit_id)
└─ change_reason

record_state (updatable via triggers only)
├─ event_uuid (PK, from app)
├─ patient_id
├─ site_id
├─ current_data (JSONB)
├─ version
├─ last_audit_id (FK → audit_id)
└─ sync_metadata

investigator_annotations
├─ annotation_id (PK)
├─ event_uuid (FK)
├─ investigator_id
├─ site_id
├─ annotation_text
├─ requires_response
└─ resolved

sites
├─ site_id (PK)
├─ site_name
└─ site_number

user_site_assignments
├─ patient_id (PK)
├─ site_id (FK)
└─ enrolled_at

investigator_site_assignments
├─ investigator_id (PK)
├─ site_id (FK)
└─ access_level

analyst_site_assignments
├─ analyst_id (PK)
├─ site_id (FK)
└─ access_level
```

---

*End of Document*
