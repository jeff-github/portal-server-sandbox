# IMPLEMENTS REQUIREMENTS:
#   REQ-o00043: Automated Deployment Pipeline
#   REQ-o00044: Database Migration Automation
#
# Staging Environment Deployment
# Manual trigger with QA Lead approval required

name: Deploy to Staging

on:
  workflow_dispatch:
    inputs:
      reason:
        description: 'Reason for staging deployment'
        required: true
        type: string

env:
  ENVIRONMENT: staging
  SUPABASE_PROJECT_ID: ${{ secrets.SUPABASE_PROJECT_ID_STAGING }}
  # Load versions from central file
  NODE_VERSION: '20'
  FLUTTER_VERSION: '3.38.3'
  SUPABASE_CLI_VERSION: '2.54.10'

jobs:
  deploy:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    permissions:
      contents: read
    timeout-minutes: 30  # Prevent hung deployments
    concurrency:
      group: deploy-staging
      cancel-in-progress: false  # Don't cancel, queue instead
    environment:
      name: staging
      url: https://staging.your-app.com  # TODO: Update with actual staging URL
    outputs:
      deployment_url: ${{ steps.set-outputs.outputs.url }}
      deployment_version: ${{ github.sha }}

    steps:
      - name: Log deployment initiation
        run: |
          echo "Staging deployment requested"
          echo "Reason: ${{ github.event.inputs.reason }}"
          echo "Requested by: ${{ github.actor }}"

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'

      - name: Setup Dart/Flutter
        uses: subosito/flutter-action@v2
        with:
          flutter-version: ${{ env.FLUTTER_VERSION }}
          channel: 'stable'

      - name: Install Supabase CLI
        run: |
          set -euo pipefail
          # Version pinned in .github/versions.env (matches Dockerfile)
          wget -qO- https://github.com/supabase/cli/releases/download/v${{ env.SUPABASE_CLI_VERSION }}/supabase_linux_amd64.tar.gz | tar xzf -
          sudo mv supabase /usr/local/bin/
          supabase --version

      - name: Install dependencies
        run: npm install

      - name: Security scan
        run: |
          set -euo pipefail

          echo "Running dependency vulnerability scan..."
          npm audit --audit-level=high

          echo "✅ Security scan passed"

      - name: Load secrets from Doppler
        uses: dopplerhq/cli-action@v3
        env:
          DOPPLER_TOKEN: ${{ secrets.DOPPLER_TOKEN_STAGING }}

      - name: Pre-deployment health check
        run: |
          set -euo pipefail

          echo "Checking staging environment health before deployment..."

          # Verify Supabase project is accessible
          if ! doppler run -- supabase link --project-ref $SUPABASE_PROJECT_ID; then
            echo "::error::Cannot access Supabase project"
            exit 1
          fi

          echo "✅ Pre-deployment health check passed"

      - name: Run full test suite
        run: |
          set -euo pipefail

          echo "Running linter..."
          npm run lint

          echo "Running type checks..."
          npm run check-types

          echo "Running unit tests..."
          npm test

          echo "Running integration tests..."
          npm run test:integration

          echo "✅ All pre-deployment tests passed"

      - name: Create database backup
        id: backup
        run: |
          set -euo pipefail
          echo "Creating database backup before migration..."

          BACKUP_FILE="backup-staging-${{ github.run_id }}.sql"
          doppler run -- supabase db dump \
            --project-ref $SUPABASE_PROJECT_ID \
            --data-only \
            -f "$BACKUP_FILE"

          # Verify backup was created
          if [ ! -f "$BACKUP_FILE" ]; then
            echo "❌ Backup file not created"
            exit 1
          fi

          echo "✅ Backup created: $BACKUP_FILE"
          echo "backup_file=$BACKUP_FILE" >> $GITHUB_OUTPUT

      - name: Database migration (with rollback on failure)
        id: migrate
        env:
          BACKUP_FILE: ${{ steps.backup.outputs.backup_file }}
        run: |
          set -euo pipefail
          echo "Starting database migration..."

          # Link to Supabase project
          doppler run -- supabase link --project-ref $SUPABASE_PROJECT_ID

          # Execute migrations
          if ! doppler run -- supabase db push; then
            echo "❌ Migration failed, restoring from backup..."

            # Restore from backup using psql
            if ! doppler run -- psql -f "$BACKUP_FILE"; then
              echo "❌ CRITICAL: Migration failed AND backup restore failed!"
              exit 2
            fi

            echo "✅ Database restored from backup"
            exit 1
          fi

          echo "✅ Migration completed successfully"

      - name: Deploy application
        run: |
          echo "Deploying application to Supabase..."
          doppler run -- supabase functions deploy --project-ref $SUPABASE_PROJECT_ID
          echo "Deployment complete"

      - name: Run smoke tests
        timeout-minutes: 10
        run: |
          set -euo pipefail

          # Check if smoke test script exists
          if [ -d "tools/testing/smoke-tests" ] && [ -x "tools/testing/smoke-tests/run-smoke-tests.sh" ]; then
            echo "Running smoke tests against deployed staging environment..."
            cd tools/testing/smoke-tests
            doppler run -- ./run-smoke-tests.sh staging | tee smoke-tests.log
            echo "✅ Smoke tests passed"
          else
            echo "⚠️ Smoke tests not yet implemented (tools/testing/smoke-tests not found)"
            echo "TODO: Implement smoke tests for deployment verification"
          fi

      # TODO: Replace with proper post-deployment integration tests
      # These should test the DEPLOYED staging environment, not local code
      # Current smoke tests above serve this purpose
      # Future: Add comprehensive end-to-end tests against staging URL

      - name: Record deployment
        if: always()
        run: |
          set -euo pipefail

          OUTCOME="${{ job.status }}"
          TIMESTAMP="$(date -u +"%Y-%m-%dT%H:%M:%SZ")"
          LOG_FILE="deployment-audit-${{ github.run_id }}.json"

          # Create structured audit log (using jq to avoid heredoc YAML issues)
          COMMIT_MSG=$(git log -1 --pretty=%B | head -1)
          jq -n \
            --arg timestamp "$TIMESTAMP" \
            --arg environment "staging" \
            --arg commit_sha "${{ github.sha }}" \
            --arg commit_message "$COMMIT_MSG" \
            --arg deployer "${{ github.actor }}" \
            --arg reason "${{ github.event.inputs.reason }}" \
            --arg outcome "$OUTCOME" \
            --arg workflow_run_id "${{ github.run_id }}" \
            --arg workflow_run_url "${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" \
            '{
              timestamp: $timestamp,
              environment: $environment,
              commit_sha: $commit_sha,
              commit_message: $commit_message,
              deployer: $deployer,
              reason: $reason,
              outcome: $outcome,
              workflow_run_id: $workflow_run_id,
              workflow_run_url: $workflow_run_url
            }' > "$LOG_FILE"

          echo "✅ Deployment audit logged: $LOG_FILE"

      - name: Upload deployment audit artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: deployment-audit-${{ github.run_id }}
          path: deployment-audit-${{ github.run_id }}.json
          retention-days: 2555  # 7 years for FDA 21 CFR Part 11 compliance

      - name: Notify QA team
        if: success()
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: smtp.gmail.com
          server_port: 587
          username: ${{ secrets.NOTIFICATION_EMAIL_USER }}
          password: ${{ secrets.NOTIFICATION_EMAIL_PASSWORD }}
          subject: "✅ Staging Deployment Successful - ${{ github.sha }}"
          to: ${{ secrets.QA_TEAM_EMAIL }}
          from: GitHub Actions
          body: |
            Staging deployment completed successfully!

            Environment: staging
            Commit: ${{ github.sha }}
            Deployer: ${{ github.actor }}
            Reason: ${{ github.event.inputs.reason }}

            View workflow: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

            The staging environment is ready for QA testing.

      - name: Rollback on failure
        if: failure()
        run: |
          set -euo pipefail

          echo "❌ Deployment failed, initiating rollback..."

          # Check if rollback script exists
          if [ -d "tools/testing/smoke-tests" ] && [ -x "tools/testing/smoke-tests/rollback.sh" ]; then
            cd tools/testing/smoke-tests
            if ! ./rollback.sh staging 2>&1 | tee rollback.log; then
              echo "❌ CRITICAL: Rollback failed!"
              cat rollback.log
              exit 2
            fi
            echo "✅ Rollback completed successfully"
          else
            echo "⚠️ Rollback script not yet implemented (tools/testing/smoke-tests/rollback.sh not found)"
            echo "Manual rollback may be required"
          fi

      - name: Notify failure
        if: failure()
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: smtp.gmail.com
          server_port: 587
          username: ${{ secrets.NOTIFICATION_EMAIL_USER }}
          password: ${{ secrets.NOTIFICATION_EMAIL_PASSWORD }}
          subject: "❌ Staging Deployment Failed - ${{ github.sha }}"
          to: ${{ secrets.QA_TEAM_EMAIL }}
          from: GitHub Actions
          body: |
            ❌ Staging deployment failed and was rolled back.

            Commit: ${{ github.sha }}
            Deployer: ${{ github.actor }}
            Reason: ${{ github.event.inputs.reason }}

            View workflow logs: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

            QA Lead: Please investigate the failure.

      - name: Record deployment metadata
        if: always()
        run: |
          set -euo pipefail

          DURATION=$SECONDS
          METADATA_FILE="deployment-metadata-${{ github.run_id }}.json"

          # Create metadata file using jq to avoid heredoc YAML issues
          COMPLETED_AT=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          NODE_VER=$(node --version)
          FLUTTER_VER=$(flutter --version | head -n1 | awk '{print $2}')
          SUPABASE_VER=$(supabase --version)
          jq -n \
            --arg deployment_id "${{ github.run_id }}" \
            --arg started_at "${{ github.event.workflow_run.created_at }}" \
            --arg completed_at "$COMPLETED_AT" \
            --argjson duration_seconds "$DURATION" \
            --arg commit_sha "${{ github.sha }}" \
            --arg deployer "${{ github.actor }}" \
            --arg node_version "$NODE_VER" \
            --arg flutter_version "$FLUTTER_VER" \
            --arg supabase_cli_version "$SUPABASE_VER" \
            '{
              deployment_id: $deployment_id,
              started_at: $started_at,
              completed_at: $completed_at,
              duration_seconds: $duration_seconds,
              commit_sha: $commit_sha,
              deployer: $deployer,
              node_version: $node_version,
              flutter_version: $flutter_version,
              supabase_cli_version: $supabase_cli_version
            }' > "$METADATA_FILE"

          echo "✅ Deployment metadata recorded"

      - name: Upload deployment metadata
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: deployment-metadata-${{ github.run_id }}
          path: deployment-metadata-${{ github.run_id }}.json
          retention-days: 90

      - name: Set deployment outputs
        id: set-outputs
        if: success()
        run: |
          # TODO: Update with actual staging URL
          STAGING_URL="https://staging.your-app.com"
          echo "url=$STAGING_URL" >> $GITHUB_OUTPUT
          echo "Staging environment: $STAGING_URL"

      - name: Cleanup artifacts
        if: always()
        run: |
          rm -f backup-staging-*.sql
          rm -f *.log
          rm -f deployment-*.json
          echo "✅ Temporary files cleaned up"
