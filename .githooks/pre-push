#!/bin/bash
# =====================================================
# Pre-Push Hook: Validation with PR-Aware Blocking
# =====================================================
#
# Runs validation scripts before push with context-aware
# blocking behavior:
#
#   - Push to branch WITH PR: BLOCKS if validation fails
#   - Push to branch WITHOUT PR: WARNS but allows push
#   - Creating/updating PR: Handled by gh pr create hooks
#
# Validation Scripts:
#   - validate_requirements.py: REQ format and links
#   - validate_index.py: INDEX.md accuracy
#   - markdownlint: Markdown formatting
#   - gitleaks: Secret detection
#   - ./tool/test.sh: Dart and TypeScript tests (per app)
#
# To install this hook:
#   git config core.hooksPath .githooks
#
# To bypass (NOT RECOMMENDED for PR branches):
#   git push --no-verify
#
# =====================================================

set -e

# Colors for output
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Get the current branch
CURRENT_BRANCH=$(git branch --show-current)

# Skip validation for main/master branches (they should only receive validated PRs)
if [ "$CURRENT_BRANCH" = "main" ] || [ "$CURRENT_BRANCH" = "master" ]; then
    echo -e "${BLUE}Skipping pre-push validation for protected branch '$CURRENT_BRANCH'${NC}"
    exit 0
fi

# =====================================================
# 1. Detect PR Status and PR-Intended Branches
# =====================================================

HAS_PR=false
PR_URL=""
IS_PR_INTENDED_BRANCH=false

# Check if branch name indicates it's intended for a PR
# Per CLAUDE.md: feature/*, fix/*, release/* branches require PRs
if [[ "$CURRENT_BRANCH" == feature/* ]] || \
   [[ "$CURRENT_BRANCH" == fix/* ]] || \
   [[ "$CURRENT_BRANCH" == release/* ]]; then
    IS_PR_INTENDED_BRANCH=true
fi

# Check if gh CLI is available
if command -v gh &> /dev/null; then
    # Check if branch has an associated PR
    if PR_INFO=$(gh pr view "$CURRENT_BRANCH" --json url,state 2>/dev/null); then
        PR_STATE=$(echo "$PR_INFO" | jq -r '.state' 2>/dev/null)
        if [ "$PR_STATE" = "OPEN" ]; then
            HAS_PR=true
            PR_URL=$(echo "$PR_INFO" | jq -r '.url' 2>/dev/null)
        fi
    fi
else
    echo -e "${YELLOW}WARNING: gh CLI not installed - cannot detect PR status${NC}"
    echo -e "${YELLOW}         Install: https://cli.github.com/${NC}"
    echo ""
fi

# PR-intended branches should be blocking even before PR exists
# This ensures validation passes BEFORE creating a PR
SHOULD_BLOCK=$HAS_PR
if [ "$IS_PR_INTENDED_BRANCH" = true ]; then
    SHOULD_BLOCK=true
fi

# =====================================================
# 2. Run Validation Scripts
# =====================================================

echo ""
echo -e "${BLUE}======================================${NC}"
echo -e "${BLUE}  Pre-Push Validation${NC}"
echo -e "${BLUE}======================================${NC}"
echo ""

if [ "$SHOULD_BLOCK" = true ]; then
    if [ "$HAS_PR" = true ]; then
        echo -e "${BLUE}Branch '$CURRENT_BRANCH' has open PR:${NC}"
        echo -e "${BLUE}  $PR_URL${NC}"
    elif [ "$IS_PR_INTENDED_BRANCH" = true ]; then
        echo -e "${BLUE}Branch '$CURRENT_BRANCH' is a PR-intended branch (feature/fix/release).${NC}"
    fi
    echo -e "${RED}Validation failures will BLOCK this push.${NC}"
else
    echo -e "${YELLOW}Branch '$CURRENT_BRANCH' has no open PR.${NC}"
    echo -e "${YELLOW}Validation failures will show warnings only.${NC}"
fi
echo ""

VALIDATION_FAILED=false
VALIDATION_OUTPUT=""

# Get repo root
REPO_ROOT=$(git rev-parse --show-toplevel)

# Run validate_requirements.py
echo -e "${BLUE}Running requirement validation...${NC}"
echo ""

if [ -f "$REPO_ROOT/tools/requirements/validate_requirements.py" ]; then
    if ! OUTPUT=$(python3 "$REPO_ROOT/tools/requirements/validate_requirements.py" 2>&1); then
        VALIDATION_FAILED=true
        VALIDATION_OUTPUT+="$OUTPUT"
        echo "$OUTPUT"
    else
        echo "$OUTPUT"
    fi
else
    echo -e "${YELLOW}WARNING: validate_requirements.py not found${NC}"
fi

echo ""

# Run validate_index.py
echo -e "${BLUE}Running INDEX.md validation...${NC}"
echo ""

if [ -f "$REPO_ROOT/tools/requirements/validate_index.py" ]; then
    if ! OUTPUT=$(python3 "$REPO_ROOT/tools/requirements/validate_index.py" 2>&1); then
        VALIDATION_FAILED=true
        VALIDATION_OUTPUT+="$OUTPUT"
        echo "$OUTPUT"
    else
        echo "$OUTPUT"
    fi
else
    echo -e "${YELLOW}WARNING: validate_index.py not found${NC}"
fi

echo ""

# =====================================================
# 3. Markdown Linting
# =====================================================

# Load central version pinning
if [ -f "$REPO_ROOT/.github/versions.env" ]; then
    while IFS='=' read -r key value; do
        # Skip comments and empty lines
        [[ "$key" =~ ^#.*$ ]] && continue
        [[ -z "$key" ]] && continue
        # Remove whitespace and export
        key=$(echo "$key" | xargs)
        value=$(echo "$value" | xargs)
        export "${key}=${value}"
    done < "$REPO_ROOT/.github/versions.env"
fi

# Get list of markdown files that will be pushed
# Compare local branch to remote tracking branch
REMOTE_BRANCH=$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null || echo "")

if [ -n "$REMOTE_BRANCH" ]; then
    MARKDOWN_FILES_CHANGED=$(git diff --name-only "$REMOTE_BRANCH"...HEAD 2>/dev/null | grep '\.md$' | grep -v 'untracked-notes/' || true)
else
    # No remote tracking branch - check all committed but unpushed markdown files
    MARKDOWN_FILES_CHANGED=$(git diff --name-only HEAD~1 HEAD 2>/dev/null | grep '\.md$' | grep -v 'untracked-notes/' || true)
fi

if [ -n "$MARKDOWN_FILES_CHANGED" ]; then
    echo -e "${BLUE}Running markdown linting...${NC}"
    echo ""

    # Check if markdownlint-cli is installed
    if command -v markdownlint &> /dev/null; then
        MARKDOWNLINT_FAILED=0

        # Filter to only files that exist (in case of deletions)
        EXISTING_FILES=""
        while IFS= read -r file; do
            if [ -f "$REPO_ROOT/$file" ]; then
                EXISTING_FILES+="$REPO_ROOT/$file"$'\n'
            fi
        done <<< "$MARKDOWN_FILES_CHANGED"

        if [ -n "$EXISTING_FILES" ]; then
            # Lint all changed markdown files at once
            if ! echo "$EXISTING_FILES" | xargs markdownlint --config "$REPO_ROOT/.markdownlint.json" 2>&1; then
                MARKDOWNLINT_FAILED=1
            fi

            if [ $MARKDOWNLINT_FAILED -eq 1 ]; then
                VALIDATION_FAILED=true
                echo ""
                echo -e "${RED}Markdown linting failed!${NC}"
                echo ""
            else
                echo -e "${GREEN}Markdown linting passed!${NC}"
            fi
        fi
    else
        echo -e "${YELLOW}WARNING: markdownlint not installed - skipping markdown linting${NC}"
        echo -e "${YELLOW}         Install: npm install -g markdownlint-cli@${MARKDOWNLINT_CLI_VERSION:-latest}${NC}"
    fi
    echo ""
else
    echo -e "${BLUE}No markdown files changed - skipping markdown linting${NC}"
    echo ""
fi

# =====================================================
# 4. Secret Detection (Gitleaks)
# =====================================================

echo -e "${BLUE}Running secret detection...${NC}"
echo ""

if command -v gitleaks &> /dev/null; then
    # Run gitleaks on the commits being pushed
    if [ -n "$REMOTE_BRANCH" ]; then
        # Check commits between remote and local
        if ! gitleaks detect --source="$REPO_ROOT" --log-opts="$REMOTE_BRANCH..HEAD" --no-banner --redact 2>&1; then
            VALIDATION_FAILED=true
            echo ""
            echo -e "${RED}Gitleaks detected secrets!${NC}"
            echo -e "${RED}Remove secrets before pushing.${NC}"
            echo ""
        else
            echo -e "${GREEN}No secrets detected!${NC}"
        fi
    else
        # No remote - scan the whole repo
        if ! gitleaks detect --source="$REPO_ROOT" --no-banner --redact 2>&1; then
            VALIDATION_FAILED=true
            echo ""
            echo -e "${RED}Gitleaks detected secrets!${NC}"
            echo ""
        else
            echo -e "${GREEN}No secrets detected!${NC}"
        fi
    fi
else
    echo -e "${RED}ERROR: gitleaks not installed - secret detection is required${NC}"
    echo -e "${RED}       Install: https://github.com/gitleaks/gitleaks#installing${NC}"
    echo ""
    VALIDATION_FAILED=true
fi

echo ""

# =====================================================
# 5. Dart Format Check
# =====================================================
# Verify ALL dart files in apps/ are properly formatted

echo -e "${BLUE}Checking Dart formatting...${NC}"
echo ""

# Check if dart is available
if command -v dart &> /dev/null; then
    DART_FORMAT_FAILED=false

    # Check each app directory with a pubspec.yaml
    for pubspec in "$REPO_ROOT"/apps/*/pubspec.yaml; do
        if [ -f "$pubspec" ]; then
            APP_DIR=$(dirname "$pubspec")
            APP_NAME=$(basename "$APP_DIR")

            echo "  Checking $APP_NAME..."

            # Run dart format check on the entire app
            if ! (cd "$APP_DIR" && dart format --output=none --set-exit-if-changed . 2>&1); then
                DART_FORMAT_FAILED=true
                echo ""
                echo -e "${RED}  ❌ $APP_NAME has unformatted Dart files${NC}"
                echo ""
            else
                echo -e "${GREEN}  ✅ $APP_NAME formatting OK${NC}"
            fi
        fi
    done

    if [ "$DART_FORMAT_FAILED" = true ]; then
        VALIDATION_FAILED=true
        echo ""
        echo -e "${RED}Dart format check failed!${NC}"
        echo -e "${RED}Run 'dart format .' in the affected app directories.${NC}"
        echo ""
    else
        echo ""
        echo -e "${GREEN}Dart format check passed!${NC}"
    fi
else
    echo -e "${RED}ERROR: dart not installed - Dart format check is required${NC}"
    echo -e "${RED}       Install Flutter/Dart: https://docs.flutter.dev/get-started/install${NC}"
    echo ""
    VALIDATION_FAILED=true
fi

echo ""

# =====================================================
# 6. Auto-Discover and Execute Plugin Pre-Push Hooks
# =====================================================

PLUGIN_DIR="$REPO_ROOT/tools/anspar-cc-plugins/plugins"

if [ -d "$PLUGIN_DIR" ]; then
    # Find all plugin pre-push hooks
    PLUGIN_HOOKS=$(find "$PLUGIN_DIR" -type f -path "*/hooks/pre-push" 2>/dev/null | sort)

    if [ -n "$PLUGIN_HOOKS" ]; then
        while IFS= read -r hook; do
            PLUGIN_NAME=$(echo "$hook" | sed 's|.*/plugins/\([^/]*\)/.*|\1|')

            # Execute the hook if it's executable
            if [ -x "$hook" ]; then
                echo -e "${BLUE}Running plugin hook: $PLUGIN_NAME${NC}"
                if ! "$hook"; then
                    VALIDATION_FAILED=true
                    echo -e "${RED}Plugin hook failed: $PLUGIN_NAME${NC}"
                fi
            fi
        done <<< "$PLUGIN_HOOKS"
    fi
fi

# =====================================================
# 7. Run Test Suites (./tool/test.sh)
# =====================================================
#
# Runs ./tool/test.sh in any app directory that has code changes.
# Each app should have its own tool/test.sh script.

echo -e "${BLUE}Running test suites...${NC}"
echo ""

# Find changed files and determine which app directories are affected
if [ -n "$REMOTE_BRANCH" ]; then
    CHANGED_FILES=$(git diff --name-only "$REMOTE_BRANCH"...HEAD 2>/dev/null || true)
else
    CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || true)
fi

# Find unique app directories with test.sh scripts
TEST_DIRS=""
while IFS= read -r changed_file; do
    # Check if file is in an app directory
    if [[ "$changed_file" == apps/* ]]; then
        # Extract the app directory (e.g., apps/clinical_diary)
        APP_DIR=$(echo "$changed_file" | cut -d'/' -f1-2)
        TEST_SCRIPT="$REPO_ROOT/$APP_DIR/tool/test.sh"

        if [ -f "$TEST_SCRIPT" ] && [ -x "$TEST_SCRIPT" ]; then
            # Add to list if not already present
            if ! echo "$TEST_DIRS" | grep -q "^$APP_DIR$"; then
                TEST_DIRS="$TEST_DIRS
$APP_DIR"
            fi
        fi
    fi
done <<< "$CHANGED_FILES"

# Remove leading newline
TEST_DIRS=$(echo "$TEST_DIRS" | sed '/^$/d')

if [ -n "$TEST_DIRS" ]; then
    while IFS= read -r app_dir; do
        TEST_SCRIPT="$REPO_ROOT/$app_dir/tool/test.sh"
        echo -e "${BLUE}Running tests for: $app_dir${NC}"
        echo ""

        if ! "$TEST_SCRIPT"; then
            VALIDATION_FAILED=true
            echo ""
            echo -e "${RED}Tests failed in $app_dir${NC}"
            echo ""
        else
            echo ""
            echo -e "${GREEN}Tests passed in $app_dir${NC}"
            echo ""
        fi
    done <<< "$TEST_DIRS"
else
    echo -e "${BLUE}No app directories with test.sh affected by changes${NC}"
    echo ""
fi

# =====================================================
# 8. Auto-Bump Clinical Diary Version
# =====================================================
# If clinical_diary source files changed in the HEAD commit, bump patch version
# Only checks the HEAD commit to avoid spurious bumps after rebases

# Get files changed in HEAD commit only (not the full push range)
HEAD_CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || true)

# Check if clinical_diary source files changed (excluding pubspec.yaml to avoid circular bumps)
CLINICAL_DIARY_CHANGED=$(echo "$HEAD_CHANGED_FILES" | grep "^apps/clinical_diary/" | grep -v "pubspec.yaml" | grep -v "pubspec.lock" || true)

if [ -n "$CLINICAL_DIARY_CHANGED" ]; then
    echo -e "${BLUE}Bumping clinical_diary version...${NC}"
    echo "  Changed files:"
    echo "$CLINICAL_DIARY_CHANGED" | sed 's/^/    /'

    PUBSPEC="$REPO_ROOT/apps/clinical_diary/pubspec.yaml"

    if [ -f "$PUBSPEC" ]; then
        # Get current version
        CURRENT_VERSION=$(grep '^version:' "$PUBSPEC" | sed 's/version: //')
        echo "  Current version: $CURRENT_VERSION"

        # Bump patch version
        (cd "$REPO_ROOT/apps/clinical_diary" && dart pub bump patch)

        # Get new version
        NEW_VERSION=$(grep '^version:' "$PUBSPEC" | sed 's/version: //')
        echo "  New version: $NEW_VERSION"

        # Stage the updated pubspec.yaml
        git add "$PUBSPEC"

        # Amend the last commit to include the version bump
        git commit --amend --no-edit --no-verify

        echo -e "${GREEN}Version bumped and commit amended${NC}"
    fi
    echo ""
else
    echo -e "${BLUE}No clinical_diary source changes in HEAD commit - skipping version bump${NC}"
    echo ""
fi

# =====================================================
# 9. Handle Validation Results
# =====================================================

echo ""
echo -e "${BLUE}======================================${NC}"
echo -e "${BLUE}  Validation Summary${NC}"
echo -e "${BLUE}======================================${NC}"
echo ""

if [ "$VALIDATION_FAILED" = true ]; then
    if [ "$SHOULD_BLOCK" = true ]; then
        # PR exists or PR-intended branch - BLOCK the push
        echo -e "${RED}VALIDATION FAILED${NC}"
        echo ""
        if [ "$HAS_PR" = true ]; then
            echo -e "${RED}Push BLOCKED because branch has an open PR.${NC}"
        elif [ "$IS_PR_INTENDED_BRANCH" = true ]; then
            echo -e "${RED}Push BLOCKED because this is a PR-intended branch (feature/fix/release).${NC}"
        fi
        echo -e "${RED}PR branches must pass all validations.${NC}"
        echo ""
        echo "To fix:"
        echo "  1. Review the validation errors above"
        echo "  2. Fix the issues in your code"
        echo "  3. Commit the fixes"
        echo "  4. Push again"
        echo ""
        echo -e "${YELLOW}To bypass (NOT RECOMMENDED):${NC}"
        echo "  git push --no-verify"
        echo ""
        exit 1
    else
        # No PR and not a PR-intended branch - warn but allow push
        echo -e "${YELLOW}VALIDATION FAILED (warnings only)${NC}"
        echo ""
        echo -e "${YELLOW}Push ALLOWED because branch has no open PR.${NC}"
        echo -e "${YELLOW}Fix these issues before creating a PR.${NC}"
        echo ""
        exit 0
    fi
else
    echo -e "${GREEN}ALL VALIDATIONS PASSED${NC}"
    echo ""
    exit 0
fi
