#!/bin/bash
# =====================================================
# Pre-Push Hook: Validation with PR-Aware Blocking
# =====================================================
#
# Runs validation scripts before push with context-aware
# blocking behavior:
#
#   - Push to branch WITH PR: BLOCKS if validation fails
#   - Push to branch WITHOUT PR: WARNS but allows push
#   - Creating/updating PR: Handled by gh pr create hooks
#
# Validation Scripts:
#   - elspais validate: REQ format and links
#   - elspais index validate: INDEX.md accuracy
#   - markdownlint: Markdown formatting
#   - gitleaks: Secret detection
#   - ./tool/test.sh: Dart and TypeScript tests (per app)
#
# To install this hook:
#   git config core.hooksPath .githooks
#
# To bypass (NOT RECOMMENDED for PR branches):
#   git push --no-verify
#
# =====================================================

set -e

# Colors for output
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Get the current branch
CURRENT_BRANCH=$(git branch --show-current)

# Skip validation for main/master branches (they should only receive validated PRs)
if [ "$CURRENT_BRANCH" = "main" ] || [ "$CURRENT_BRANCH" = "master" ]; then
    echo -e "${BLUE}Skipping pre-push validation for protected branch '$CURRENT_BRANCH'${NC}"
    exit 0
fi

# =====================================================
# 1. Detect PR Status and PR-Intended Branches
# =====================================================

HAS_PR=false
PR_URL=""
IS_PR_INTENDED_BRANCH=false

# Check if branch name indicates it's intended for a PR
# Per CLAUDE.md: feature/*, fix/*, release/* branches require PRs
if [[ "$CURRENT_BRANCH" == feature/* ]] || \
   [[ "$CURRENT_BRANCH" == fix/* ]] || \
   [[ "$CURRENT_BRANCH" == release/* ]]; then
    IS_PR_INTENDED_BRANCH=true
fi

# Check if gh CLI is available
if command -v gh &> /dev/null; then
    # Check if branch has an associated PR
    if PR_INFO=$(gh pr view "$CURRENT_BRANCH" --json url,state 2>/dev/null); then
        PR_STATE=$(echo "$PR_INFO" | jq -r '.state' 2>/dev/null)
        if [ "$PR_STATE" = "OPEN" ]; then
            HAS_PR=true
            PR_URL=$(echo "$PR_INFO" | jq -r '.url' 2>/dev/null)
        fi
    fi
else
    echo -e "${YELLOW}WARNING: gh CLI not installed - cannot detect PR status${NC}"
    echo -e "${YELLOW}         Install: https://cli.github.com/${NC}"
    echo ""
fi

# PR-intended branches should be blocking even before PR exists
# This ensures validation passes BEFORE creating a PR
SHOULD_BLOCK=$HAS_PR
if [ "$IS_PR_INTENDED_BRANCH" = true ]; then
    SHOULD_BLOCK=true
fi

# =====================================================
# 2. Run Validation Scripts
# =====================================================

echo ""
echo -e "${BLUE}======================================${NC}"
echo -e "${BLUE}  Pre-Push Validation${NC}"
echo -e "${BLUE}======================================${NC}"
echo ""

if [ "$SHOULD_BLOCK" = true ]; then
    if [ "$HAS_PR" = true ]; then
        echo -e "${BLUE}Branch '$CURRENT_BRANCH' has open PR:${NC}"
        echo -e "${BLUE}  $PR_URL${NC}"
    elif [ "$IS_PR_INTENDED_BRANCH" = true ]; then
        echo -e "${BLUE}Branch '$CURRENT_BRANCH' is a PR-intended branch (feature/fix/release).${NC}"
    fi
    echo -e "${RED}Validation failures will BLOCK this push.${NC}"
else
    echo -e "${YELLOW}Branch '$CURRENT_BRANCH' has no open PR.${NC}"
    echo -e "${YELLOW}Validation failures will show warnings only.${NC}"
fi
echo ""

VALIDATION_FAILED=false
VALIDATION_OUTPUT=""

# Get repo root
REPO_ROOT=$(git rev-parse --show-toplevel)

# Run elspais validate (REQ format and links)
echo -e "${BLUE}Running requirement validation...${NC}"
echo ""

if command -v elspais &> /dev/null; then
    if ! OUTPUT=$(elspais validate --mode core 2>&1); then
        VALIDATION_FAILED=true
        VALIDATION_OUTPUT+="$OUTPUT"
        echo "$OUTPUT"
    else
        echo "$OUTPUT"
    fi
else
    echo -e "${RED}ERROR: elspais not installed - requirement validation is required${NC}"
    VALIDATION_FAILED=true
fi

echo ""

# Run elspais index validate (INDEX.md accuracy)
echo -e "${BLUE}Running INDEX.md validation...${NC}"
echo ""

if command -v elspais &> /dev/null; then
    if ! OUTPUT=$(elspais index --mode core validate 2>&1); then
        VALIDATION_FAILED=true
        VALIDATION_OUTPUT+="$OUTPUT"
        echo "$OUTPUT"
    else
        echo "$OUTPUT"
    fi
else
    echo -e "${RED}ERROR: elspais not installed - INDEX.md validation is required${NC}"
    VALIDATION_FAILED=true
fi

echo ""

# =====================================================
# 3. Markdown Linting
# =====================================================

# Load central version pinning
if [ -f "$REPO_ROOT/.github/versions.env" ]; then
    while IFS='=' read -r key value; do
        # Skip comments and empty lines
        [[ "$key" =~ ^#.*$ ]] && continue
        [[ -z "$key" ]] && continue
        # Remove whitespace and export
        key=$(echo "$key" | xargs)
        value=$(echo "$value" | xargs)
        export "${key}=${value}"
    done < "$REPO_ROOT/.github/versions.env"
fi

# Get list of markdown files that will be pushed
# Compare local branch to remote tracking branch
REMOTE_BRANCH=$(git rev-parse --abbrev-ref --symbolic-full-name @{u} 2>/dev/null || echo "")

if [ -n "$REMOTE_BRANCH" ]; then
    MARKDOWN_FILES_CHANGED=$(git diff --name-only "$REMOTE_BRANCH"...HEAD 2>/dev/null | grep '\.md$' | grep -v 'untracked-notes/' || true)
else
    # No remote tracking branch - check all committed but unpushed markdown files
    MARKDOWN_FILES_CHANGED=$(git diff --name-only HEAD~1 HEAD 2>/dev/null | grep '\.md$' | grep -v 'untracked-notes/' || true)
fi

if [ -n "$MARKDOWN_FILES_CHANGED" ]; then
    echo -e "${BLUE}Running markdown linting...${NC}"
    echo ""

    # Check if markdownlint-cli is installed
    if command -v markdownlint &> /dev/null; then
        MARKDOWNLINT_FAILED=0

        # Filter to only files that exist (in case of deletions)
        EXISTING_FILES=""
        while IFS= read -r file; do
            if [ -f "$REPO_ROOT/$file" ]; then
                EXISTING_FILES+="$REPO_ROOT/$file"$'\n'
            fi
        done <<< "$MARKDOWN_FILES_CHANGED"

        if [ -n "$EXISTING_FILES" ]; then
            # Lint all changed markdown files at once
            if ! echo "$EXISTING_FILES" | xargs markdownlint --config "$REPO_ROOT/.markdownlint.json" 2>&1; then
                MARKDOWNLINT_FAILED=1
            fi

            if [ $MARKDOWNLINT_FAILED -eq 1 ]; then
                VALIDATION_FAILED=true
                echo ""
                echo -e "${RED}Markdown linting failed!${NC}"
                echo ""
            else
                echo -e "${GREEN}Markdown linting passed!${NC}"
            fi
        fi
    else
        echo -e "${YELLOW}WARNING: markdownlint not installed - skipping markdown linting${NC}"
        echo -e "${YELLOW}         Install: npm install -g markdownlint-cli@${MARKDOWNLINT_CLI_VERSION:-latest}${NC}"
    fi
    echo ""
else
    echo -e "${BLUE}No markdown files changed - skipping markdown linting${NC}"
    echo ""
fi

# =====================================================
# 4. Secret Detection (Gitleaks)
# =====================================================

echo -e "${BLUE}Running secret detection...${NC}"
echo ""

if command -v gitleaks &> /dev/null; then
    # Run gitleaks on the commits being pushed
    if [ -n "$REMOTE_BRANCH" ]; then
        # Check commits between remote and local
        if ! gitleaks detect --source="$REPO_ROOT" --log-opts="$REMOTE_BRANCH..HEAD" --no-banner --redact 2>&1; then
            VALIDATION_FAILED=true
            echo ""
            echo -e "${RED}Gitleaks detected secrets!${NC}"
            echo -e "${RED}Remove secrets before pushing.${NC}"
            echo ""
        else
            echo -e "${GREEN}No secrets detected!${NC}"
        fi
    else
        # No remote - scan the whole repo
        if ! gitleaks detect --source="$REPO_ROOT" --no-banner --redact 2>&1; then
            VALIDATION_FAILED=true
            echo ""
            echo -e "${RED}Gitleaks detected secrets!${NC}"
            echo ""
        else
            echo -e "${GREEN}No secrets detected!${NC}"
        fi
    fi
else
    echo -e "${RED}ERROR: gitleaks not installed - secret detection is required${NC}"
    echo -e "${RED}       Install: https://github.com/gitleaks/gitleaks#installing${NC}"
    echo ""
    VALIDATION_FAILED=true
fi

echo ""

# =====================================================
# 5. Dart Pub Get (dependency resolution)
# =====================================================
# Ensure all dependencies are resolved before format/analyze checks

echo -e "${BLUE}Resolving Dart dependencies...${NC}"
echo ""

if command -v dart &> /dev/null; then
    # Find all pubspec.yaml files in apps/ (including nested packages)
    while IFS= read -r pubspec; do
        if [ -f "$pubspec" ]; then
            APP_DIR=$(dirname "$pubspec")
            APP_NAME=${APP_DIR#$REPO_ROOT/apps/}

            echo "  Getting dependencies for $APP_NAME..."

            # Run dart pub get (or flutter pub get if it's a Flutter project)
            if [ -f "$APP_DIR/lib/main.dart" ] || grep -q "flutter:" "$pubspec" 2>/dev/null; then
                # Flutter project
                if command -v flutter &> /dev/null; then
                    (cd "$APP_DIR" && flutter pub get --suppress-analytics) > /dev/null 2>&1 || true
                else
                    (cd "$APP_DIR" && dart pub get) > /dev/null 2>&1 || true
                fi
            else
                # Pure Dart project
                (cd "$APP_DIR" && dart pub get) > /dev/null 2>&1 || true
            fi
        fi
    done < <(find "$REPO_ROOT/apps" -name "pubspec.yaml" -type f 2>/dev/null)

    echo -e "${GREEN}Dependencies resolved${NC}"
else
    echo -e "${YELLOW}WARNING: dart not available - skipping dependency resolution${NC}"
fi

echo ""

# =====================================================
# 5.1. Dart Format Check
# =====================================================
# Verify ALL dart files in apps/ are properly formatted

echo -e "${BLUE}Checking Dart formatting...${NC}"
echo ""

# Check if dart is available
if command -v dart &> /dev/null; then
    DART_FORMAT_FAILED=false

    # Find all pubspec.yaml files in apps/ (including nested packages)
    while IFS= read -r pubspec; do
        if [ -f "$pubspec" ]; then
            APP_DIR=$(dirname "$pubspec")
            APP_NAME=${APP_DIR#$REPO_ROOT/apps/}

            echo "  Checking $APP_NAME..."

            # Run dart format check on the entire app
            if ! (cd "$APP_DIR" && dart format --output=none --set-exit-if-changed . 2>&1); then
                DART_FORMAT_FAILED=true
                echo ""
                echo -e "${RED}  ❌ $APP_NAME has unformatted Dart files${NC}"
                echo ""
            else
                echo -e "${GREEN}  ✅ $APP_NAME formatting OK${NC}"
            fi
        fi
    done < <(find "$REPO_ROOT/apps" -name "pubspec.yaml" -type f 2>/dev/null)

    if [ "$DART_FORMAT_FAILED" = true ]; then
        VALIDATION_FAILED=true
        echo ""
        echo -e "${RED}Dart format check failed!${NC}"
        echo -e "${RED}Run 'dart format .' in the affected app directories.${NC}"
        echo ""
    else
        echo ""
        echo -e "${GREEN}Dart format check passed!${NC}"
    fi
else
    echo -e "${RED}ERROR: dart not installed - Dart format check is required${NC}"
    echo -e "${RED}       Install Flutter/Dart: https://docs.flutter.dev/get-started/install${NC}"
    echo ""
    VALIDATION_FAILED=true
fi

echo ""

# =====================================================
# 5.2. Dart Analyze Check
# =====================================================
# Verify ALL dart code in apps/ passes dart analyze --fatal-infos

echo -e "${BLUE}Running Dart static analysis...${NC}"
echo ""

# Check if dart is available
if command -v dart &> /dev/null; then
    DART_ANALYZE_FAILED=false

    # Find all pubspec.yaml files in apps/ (including nested packages)
    while IFS= read -r pubspec; do
        if [ -f "$pubspec" ]; then
            APP_DIR=$(dirname "$pubspec")
            APP_NAME=${APP_DIR#$REPO_ROOT/apps/}

            echo "  Analyzing $APP_NAME..."

            # Run dart analyze with fatal-infos (even info-level issues fail)
            if ! (cd "$APP_DIR" && dart analyze --fatal-infos 2>&1); then
                DART_ANALYZE_FAILED=true
                echo ""
                echo -e "${RED}  ❌ $APP_NAME has analysis issues${NC}"
                echo ""
            else
                echo -e "${GREEN}  ✅ $APP_NAME analysis OK${NC}"
            fi
        fi
    done < <(find "$REPO_ROOT/apps" -name "pubspec.yaml" -type f 2>/dev/null)

    if [ "$DART_ANALYZE_FAILED" = true ]; then
        VALIDATION_FAILED=true
        echo ""
        echo -e "${RED}Dart analyze check failed!${NC}"
        echo -e "${RED}Fix all analysis issues (including infos) before pushing.${NC}"
        echo ""
    else
        echo ""
        echo -e "${GREEN}Dart analyze check passed!${NC}"
    fi
else
    echo -e "${RED}ERROR: dart not installed - Dart analyze check is required${NC}"
    echo ""
    VALIDATION_FAILED=true
fi

echo ""

# =====================================================
# 6. Auto-Discover and Execute Plugin Pre-Push Hooks
# =====================================================

PLUGIN_DIR="$REPO_ROOT/tools/anspar-cc-plugins/plugins"

if [ -d "$PLUGIN_DIR" ]; then
    # Find all plugin pre-push hooks
    PLUGIN_HOOKS=$(find "$PLUGIN_DIR" -type f -path "*/hooks/pre-push" 2>/dev/null | sort)

    if [ -n "$PLUGIN_HOOKS" ]; then
        while IFS= read -r hook; do
            PLUGIN_NAME=$(echo "$hook" | sed 's|.*/plugins/\([^/]*\)/.*|\1|')

            # Execute the hook if it's executable
            if [ -x "$hook" ]; then
                echo -e "${BLUE}Running plugin hook: $PLUGIN_NAME${NC}"
                if ! "$hook"; then
                    VALIDATION_FAILED=true
                    echo -e "${RED}Plugin hook failed: $PLUGIN_NAME${NC}"
                fi
            fi
        done <<< "$PLUGIN_HOOKS"
    fi
fi

# =====================================================
# 7. Run Test Suites (./tool/test.sh)
# =====================================================
#
# Runs ./tool/test.sh in any app directory that has code changes.
# Each app should have its own tool/test.sh script.
# Supports nested packages (e.g., apps/daily-diary/diary_functions/).

echo -e "${BLUE}Running test suites...${NC}"
echo ""

# Find changed files and determine which app directories are affected
if [ -n "$REMOTE_BRANCH" ]; then
    CHANGED_FILES=$(git diff --name-only "$REMOTE_BRANCH"...HEAD 2>/dev/null || true)
else
    CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD 2>/dev/null || true)
fi

# Find unique app directories with test.sh scripts
# Walk up from each changed file to find the nearest tool/test.sh
TEST_DIRS=""
while IFS= read -r changed_file; do
    # Check if file is in an app directory
    if [[ "$changed_file" == apps/* ]]; then
        # Walk up from the changed file to find nearest tool/test.sh
        DIR=$(dirname "$REPO_ROOT/$changed_file")
        while [[ "$DIR" == "$REPO_ROOT/apps"* ]] && [ "$DIR" != "$REPO_ROOT/apps" ]; do
            TEST_SCRIPT="$DIR/tool/test.sh"
            if [ -f "$TEST_SCRIPT" ] && [ -x "$TEST_SCRIPT" ]; then
                # Get relative path from repo root
                REL_DIR=${DIR#$REPO_ROOT/}
                # Add to list if not already present
                if ! echo "$TEST_DIRS" | grep -q "^$REL_DIR$"; then
                    TEST_DIRS="$TEST_DIRS
$REL_DIR"
                fi
                break
            fi
            DIR=$(dirname "$DIR")
        done
    fi
done <<< "$CHANGED_FILES"

# Remove leading newline
TEST_DIRS=$(echo "$TEST_DIRS" | sed '/^$/d')

if [ -n "$TEST_DIRS" ]; then
    while IFS= read -r app_dir; do
        TEST_SCRIPT="$REPO_ROOT/$app_dir/tool/test.sh"
        echo -e "${BLUE}Running tests for: $app_dir${NC}"
        echo ""

        if ! "$TEST_SCRIPT"; then
            VALIDATION_FAILED=true
            echo ""
            echo -e "${RED}Tests failed in $app_dir${NC}"
            echo ""
        else
            echo ""
            echo -e "${GREEN}Tests passed in $app_dir${NC}"
            echo ""
        fi
    done <<< "$TEST_DIRS"
else
    echo -e "${BLUE}No app directories with test.sh affected by changes${NC}"
    echo ""
fi

# =====================================================
# 8. Auto-Bump Build Numbers (+N in pubspec.yaml)
# =====================================================
#
# Detects which Dart/Flutter projects have source changes
# (including dependencies) and increments the +N build number.
# Creates a commit with the bumped versions so the push
# includes the updated build numbers.
#
# Project trigger paths include transitive dependencies:
# e.g., a change in trial_data_types bumps clinical_diary.

echo -e "${BLUE}Checking build number bumps...${NC}"
echo ""

# Determine changed files vs main
BUMP_BASE_BRANCH="origin/main"
if ! git rev-parse --verify "$BUMP_BASE_BRANCH" &>/dev/null; then
    BUMP_BASE_BRANCH="main"
fi

BUMP_CHANGED_FILES=""
if git rev-parse --verify "$BUMP_BASE_BRANCH" &>/dev/null; then
    BUMP_CHANGED_FILES=$(git diff --name-only "$BUMP_BASE_BRANCH"...HEAD 2>/dev/null || true)
fi

if [ -n "$BUMP_CHANGED_FILES" ]; then
    # Project definitions: name|pubspec_path|trigger_paths (space-separated)
    # If ANY changed file starts with a trigger path, the project's
    # build number is bumped. Dependencies included as trigger paths.
    BUMP_PROJECTS=(
        # Deployable apps
        "clinical_diary|apps/daily-diary/clinical_diary/pubspec.yaml|apps/daily-diary/clinical_diary/ apps/common-dart/trial_data_types/ apps/common-dart/append_only_datastore/ apps/daily-diary/diary_functions/ apps/common-flutter/eq/"
        "portal-ui|apps/sponsor-portal/portal-ui/pubspec.yaml|apps/sponsor-portal/portal-ui/ apps/sponsor-portal/portal_functions/ apps/common-dart/trial_data_types/"
        "diary_server|apps/daily-diary/diary_server/pubspec.yaml|apps/daily-diary/diary_server/ apps/daily-diary/diary_functions/ apps/common-dart/trial_data_types/ database/"
        "portal_server|apps/sponsor-portal/portal_server/pubspec.yaml|apps/sponsor-portal/portal_server/ apps/sponsor-portal/portal_functions/ apps/common-dart/trial_data_types/ database/"
        # Libraries
        "trial_data_types|apps/common-dart/trial_data_types/pubspec.yaml|apps/common-dart/trial_data_types/"
        "append_only_datastore|apps/common-dart/append_only_datastore/pubspec.yaml|apps/common-dart/append_only_datastore/"
        "diary_functions|apps/daily-diary/diary_functions/pubspec.yaml|apps/daily-diary/diary_functions/ apps/common-dart/trial_data_types/"
        "portal_functions|apps/sponsor-portal/portal_functions/pubspec.yaml|apps/sponsor-portal/portal_functions/ apps/common-dart/trial_data_types/"
        "eq|apps/common-flutter/eq/pubspec.yaml|apps/common-flutter/eq/ apps/common-dart/trial_data_types/"
        "rave-integration|apps/edc/rave-integration/pubspec.yaml|apps/edc/rave-integration/"
    )

    BUMPED_LIST=""

    for project_def in "${BUMP_PROJECTS[@]}"; do
        IFS='|' read -r name pubspec triggers <<< "$project_def"

        FULL_PUBSPEC="$REPO_ROOT/$pubspec"

        # Skip if pubspec doesn't exist
        if [ ! -f "$FULL_PUBSPEC" ]; then
            continue
        fi

        # Check if any trigger path matches a changed file
        should_bump=false
        for trigger in $triggers; do
            if echo "$BUMP_CHANGED_FILES" | grep -q "^${trigger}"; then
                # Exclude pubspec.yaml and pubspec.lock from triggering (avoid circular bumps)
                non_pubspec=$(echo "$BUMP_CHANGED_FILES" | grep "^${trigger}" | grep -v "pubspec.yaml" | grep -v "pubspec.lock" || true)
                if [ -n "$non_pubspec" ]; then
                    should_bump=true
                    break
                fi
            fi
        done

        if [ "$should_bump" = true ]; then
            current=$(grep '^version:' "$FULL_PUBSPEC" | sed 's/version: //')

            # Parse base version (before +) and build number (after +)
            base_version="${current%%+*}"
            if [[ "$current" == *"+"* ]]; then
                build_num="${current##*+}"
            else
                build_num=0
            fi

            new_build=$((build_num + 1))
            new_version="${base_version}+${new_build}"

            # Update pubspec.yaml (portable: works on both BSD and GNU sed)
            if sed --version >/dev/null 2>&1; then
                # GNU sed
                sed -i "s/^version: .*/version: ${new_version}/" "$FULL_PUBSPEC"
            else
                # BSD sed (macOS)
                sed -i '' "s/^version: .*/version: ${new_version}/" "$FULL_PUBSPEC"
            fi

            echo -e "  ${GREEN}$name: $current -> $new_version${NC}"
            BUMPED_LIST="${BUMPED_LIST} ${name}"
        fi
    done

    if [ -n "$BUMPED_LIST" ]; then
        echo ""
        echo -e "${BLUE}Committing build number bumps...${NC}"

        # Stage only the pubspec.yaml files we modified
        for project_def in "${BUMP_PROJECTS[@]}"; do
            IFS='|' read -r name pubspec triggers <<< "$project_def"
            if echo "$BUMPED_LIST" | grep -q "$name"; then
                git add "$REPO_ROOT/$pubspec"
            fi
        done

        git commit -m "Bump build numbers for${BUMPED_LIST}" --no-verify

        echo -e "${GREEN}Build numbers bumped for:${BUMPED_LIST}${NC}"
    else
        echo -e "${BLUE}No projects need build number bumps${NC}"
    fi
else
    echo -e "${BLUE}No changed files detected - skipping build number bumps${NC}"
fi

echo ""

# =====================================================
# 9. Handle Validation Results
# =====================================================

echo ""
echo -e "${BLUE}======================================${NC}"
echo -e "${BLUE}  Validation Summary${NC}"
echo -e "${BLUE}======================================${NC}"
echo ""

if [ "$VALIDATION_FAILED" = true ]; then
    if [ "$SHOULD_BLOCK" = true ]; then
        # PR exists or PR-intended branch - BLOCK the push
        echo -e "${RED}VALIDATION FAILED${NC}"
        echo ""
        if [ "$HAS_PR" = true ]; then
            echo -e "${RED}Push BLOCKED because branch has an open PR.${NC}"
        elif [ "$IS_PR_INTENDED_BRANCH" = true ]; then
            echo -e "${RED}Push BLOCKED because this is a PR-intended branch (feature/fix/release).${NC}"
        fi
        echo -e "${RED}PR branches must pass all validations.${NC}"
        echo ""
        echo "To fix:"
        echo "  1. Review the validation errors above"
        echo "  2. Fix the issues in your code"
        echo "  3. Commit the fixes"
        echo "  4. Push again"
        echo ""
        echo -e "${YELLOW}To bypass (NOT RECOMMENDED):${NC}"
        echo "  git push --no-verify"
        echo ""
        exit 1
    else
        # No PR and not a PR-intended branch - warn but allow push
        echo -e "${YELLOW}VALIDATION FAILED (warnings only)${NC}"
        echo ""
        echo -e "${YELLOW}Push ALLOWED because branch has no open PR.${NC}"
        echo -e "${YELLOW}Fix these issues before creating a PR.${NC}"
        echo ""
        exit 0
    fi
else
    echo -e "${GREEN}ALL VALIDATIONS PASSED${NC}"
    echo ""
    exit 0
fi
